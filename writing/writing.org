#+title: Writing related config
#+author: Javier Castilla
#+EMAIL: jcastp@pm.me
#+language: es

This is my personal config for writing.

* Writeroom
Distraction free writing mode.
https://github.com/joostkremers/writeroom-mode

#+begin_src emacs-lisp
  (use-package writeroom-mode
    :ensure t
    :config
    (global-set-key (kbd "C-c 5") 'writeroom-mode)
    ;; width of the writing area
    (setq writeroom-width 90)
    ;; extra space between the lines to see better
    (setq writeroom-extra-line-spacing 4)
    ;; Checking the modeline
    (setq writeroom-mode-line t)
    )
#+end_src

* Word count
Word counting with objective.

#+begin_src emacs-lisp
  (use-package wc-mode
    :ensure t
    :config
    (global-set-key (kbd "C-c 9") 'wc-mode)
    )
#+end_src

* CANCELED word count on subsections
https://lists.gnu.org/archive/html/emacs-orgmode/2011-04/msg00713.html

#+begin_src emacs-lisp :tangle no
  (use-package org-wc
    :ensure t)
#+end_src

* Count words in orgmode, excluding comments, drawers, properties, etc
=count-words= function is good, but in orgmode still counts all the words, including comments, properties,drawers, etc.

These functions avoid that.
The main function is =org-context-count-words=, that has an extensive documentation.

#+begin_src emacs-lisp
  (use-package org-context-extended
    :ensure t
    :vc (:url "https://codeberg.org/jcastp/org-context-extended"
  	    :branch "main"
  	    :rev :newest))
#+end_src

* Add a property for orgmode headings with an advanced word count function
Modified the Emacs Writing Studio ([[https://github.com/pprevos/emacs-writing-studio][EWS]]) function to use my orgmode word count function.
It adds a property, called WORDCOUNT, to the headings so we can leverage in reports or other actions.
It also adds a custom id under every org heading, so we can link back to it.

#+begin_src emacs-lisp
      (defun writing/ews-org-count-words ()
      "Add word count to each heading property drawer in an Org mode buffer."
      (interactive)
      (org-map-entries
       (lambda ()
         (let* ((start (point))
                (end (save-excursion (org-end-of-subtree)))
                (word-count (org-context-count-words start end t t t t t t org-context-ignore-tags)))
           (org-set-property "WORDCOUNT" (number-to-string word-count)))
         ;; create the id to link the org heading
         (org-id-get-create))))
#+end_src

* TODO Dynamic block function to draw the wordcount of the sections
This function relies on a property in the org-heading called WORDCOUNT, that is generated by the function =writing/ews-org-count-words=. It will draw a sorted table with the word count of each section.

To create the dynamic block in the file, add this in the org file
#+begin_src
#+BEGIN: org-generate-wordcount-table
| Heading       | Wordcount |
|---------------+-----------|
| * [[CapÃ­tulo 01]] |         4 |
| * [[CapÃ­tulo 02]] |         1 |

#+END:
#+end_src

#+begin_src emacs-lisp
  (defun org-dblock-write:org-generate-wordcount-table (params)
    "Generate a table with heading names and their WORDCOUNT property in Org mode."
    (interactive)
    ;; We execute the function of counting words, add the WORDCOUNT property,
    ;; and update the current word count.
    (writing/ews-org-count-words)
    (let (table-data)
      ;; Traverse each Org entry in the current buffer
      (org-map-entries
       (lambda ()
         (let* ((heading-components (org-heading-components))
                (heading (nth 4 heading-components))  ; Extract heading text
                (level (car heading-components)) ;Extract level
  	      (tags (org-get-tags))
                (wordcount (org-entry-get nil "WORDCOUNT")))
  	 ;; check if we get tags, and if they don't contain the noexport
  	 (if (not (and tags (member "noexport" tags)))	       
  	   ;; add the data in the table-data for each heading
  	   (push (cons
  		  ;; add the asterisks (ascii 42), the space (ascii 32) and the heading, but when more than 2 asterisks are present, it interprets as a bold marking character
  		  ;;(format "%s%s%s" (make-string level 42) (make-string 1 32) (org-link-make-string heading))
  		  ;; this format provides the literal strings, but org-appear makes it unaligned
  		  (format "=%s= %s" (make-string level 42) (org-link-make-string heading))
  		  ;; This format escapes the asterisks, making the appearance confusing
  		  ;;(format "%s %s" (replace-regexp-in-string "\\*" "\\\\*" (make-string level 42)) (org-link-make-string heading))
  		  ;; add the wordcount
  		  wordcount)
  		 ;; add all to the table-data
  		 table-data)))))
      (insert "| Heading         | Wordcount |\n"
              "|-----------------+-----------|\n")
      (dolist (pair (reverse table-data))
        (insert (format "| %s | %s |\n" (car pair) (cdr pair)))
        (org-table-align))))
#+end_src

* org-tracktable - daily word count track table
A table to track the advance of your writing: https://codeberg.org/jcastp/org-tracktable

Loading my new implementation from my personal repository. This depends on the =org-context-extended.el=  file.

#+begin_src emacs-lisp
  (use-package org-tracktable
    :ensure t
    :vc (:url "https://codeberg.org/jcastp/org-tracktable"
  	    :branch "main"
  	    :rev :newest))
#+end_src

* TODO guess-language
Since I write in different languages, the dictionary applied is really important. If I write in Spanish, I want the spanish dict to be applied, and not the english one.

#+begin_src emacs-lisp
  (use-package guess-language
    :ensure t
    :config
    (setq guess-language-languages '(en es))
    (setq guess-language-min-paragraph-length 40)
    ;; define the dicts I want to use for my languages
    (setq guess-language-langcodes
  	'((en . ("en_US" "English"))
  	  (es . ("es_ES" "Spanish"))))
    (guess-language-mode)
    ;; activate the mode when I go to text files
    (add-hook 'text-mode-hook (lambda () (guess-language-mode 1)))
    (add-hook 'org-mode-hook (lambda () (guess-language-mode 1)))
    )
#+end_src

* Buscar en la RAE (API)
Search a word using the RAE API which returns structured JSON data with definitions, etymology, conjugations, and more.

#+begin_src emacs-lisp
  (require 'json)
  (require 'url)

  (defun writing/rae-api-lookup (palabra)
    "Look up PALABRA in the RAE dictionary using the API.
  Displays the word definition, etymology, and meanings in a buffer."
    (interactive "sPalabra a buscar en la RAE: ")
    (let* ((url (format "https://rae-api.com/api/words/%s"
                        (url-hexify-string palabra)))
           (buffer-name (format "*RAE: %s*" palabra))
           (url-request-method "GET"))
      (url-retrieve
       url
       (lambda (status palabra buffer-name)
         (if (plist-get status :error)
             (message "Error al buscar la palabra: %s"
                      (plist-get status :error))
           ;; Move past HTTP headers
           (goto-char (point-min))
           (re-search-forward "^$")
           (let* ((json-object-type 'hash-table)
                  (json-array-type 'list)
                  (json-key-type 'string)
                  (json-data (json-read))
                  (ok (gethash "ok" json-data))
                  (output-buffer (get-buffer-create buffer-name)))
             (with-current-buffer output-buffer
               (erase-buffer)
               (org-mode)
               (if ok
                   (writing/rae-format-result json-data palabra)
                 ;; Word not found - show suggestions
                 (let ((suggestions (gethash "suggestions" json-data)))
                   (insert (format "* Palabra no encontrada: %s\n\n" palabra))
                   (insert "** Sugerencias:\n")
                   (dolist (suggestion suggestions)
                     (insert (format "- %s\n" suggestion)))))
               (goto-char (point-min)))
             (display-buffer output-buffer))))
       (list palabra buffer-name))))

  (defun writing/rae-format-result (json-data palabra)
    "Format the JSON-DATA response from RAE API into an org-mode buffer."
    (let* ((data (gethash "data" json-data))
           (word (gethash "word" data))
           (meanings (gethash "meanings" data)))
      (insert (format "#+TITLE: %s\n\n" word))

      ;; Process each meaning
      (dolist (meaning meanings)
        (let ((origin (gethash "origin" meaning))
              (senses (gethash "senses" meaning))
              (conjugations (gethash "conjugations" meaning)))

          ;; Etymology - origin is an object with 'text' or 'raw' field
          (when origin
            (insert "* EtimologÃ­a\n")
            (let ((origin-text (or (gethash "text" origin)
                                   (gethash "raw" origin))))
              (when origin-text
                (insert (format "%s\n\n" origin-text)))))

          ;; Definitions
          (insert "* Definiciones\n\n")
          (let ((sense-num 1))
            (dolist (sense senses)
              (let ((category (gethash "category" sense))
                    (verb-category (gethash "verb_category" sense))
                    (description (gethash "description" sense))
                    (synonyms (gethash "synonyms" sense))
                    (antonyms (gethash "antonyms" sense)))

                ;; Build category string
                (let ((cat-str (cond
                                ((and category verb-category)
                                 (format "/%s %s/" category verb-category))
                                (category (format "/%s/" category))
                                (t ""))))
                  (insert (format "** %d. %s\n" sense-num cat-str)))

                ;; Description (this is the actual definition)
                (when description
                  (insert (format "%s\n\n" description)))

                ;; Synonyms
                (when (and synonyms (> (length synonyms) 0))
                  (insert (format "*** SinÃ³nimos: %s\n\n"
                                  (mapconcat 'identity synonyms ", "))))

                ;; Antonyms
                (when (and antonyms (> (length antonyms) 0))
                  (insert (format "*** AntÃ³nimos: %s\n\n"
                                  (mapconcat 'identity antonyms ", "))))

                (setq sense-num (1+ sense-num)))))

          ;; Conjugations (for verbs)
          (when conjugations
            (insert "* Conjugaciones\n\n")
            (writing/rae-format-conjugations conjugations))))))

  (defun writing/rae-format-conjugations (conjugations)
    "Format verb conjugations from the RAE API response."
    (when conjugations
      ;; Simple formatting - you can enhance this later
      (insert "#+begin_example\n")
      (maphash
       (lambda (mood forms)
         (insert (format "\n%s:\n" (upcase (if (stringp mood) mood (symbol-name mood)))))
         (when (hash-table-p forms)
           (maphash
            (lambda (tense persons)
              (insert (format "  %s:\n" (if (stringp tense) tense (symbol-name tense))))
              (when (hash-table-p persons)
                (maphash
                 (lambda (person form)
                   (insert (format "    %s: %s\n"
                                   (if (stringp person) person (symbol-name person))
                                   form)))
                 persons)))
            forms)))
       conjugations)
      (insert "#+end_example\n\n")))

  (defun writing/rae-api-random ()
    "Get a random word from the RAE dictionary."
    (interactive)
    (let* ((url "https://rae-api.com/api/random")
           (url-request-method "GET"))
      (url-retrieve
       url
       (lambda (status)
         (if (plist-get status :error)
             (message "Error al obtener palabra aleatoria: %s"
                      (plist-get status :error))
           (goto-char (point-min))
           (re-search-forward "^$")
           (let* ((json-object-type 'hash-table)
                  (json-array-type 'list)
                  (json-key-type 'string)
                  (json-data (json-read))
                  (palabra (gethash "word" (gethash "data" json-data))))
             (kill-buffer)
             (when palabra
               (writing/rae-api-lookup palabra))))))))

  ;; (defun writing/rae-api-daily ()
  ;;   "Get the word of the day from the RAE dictionary."
  ;;   (interactive)
  ;;   (let* ((url-request-method "GET")
  ;;          (url-request-extra-headers
  ;;           '(("Accept" . "application/json")
  ;;             ("User-Agent" . "Emacs"))))
  ;;     (url-retrieve
  ;;      "https://rae-api.com/api/daily"
  ;;      (lambda (status)
  ;;        (unwind-protect
  ;;            (progn
  ;;              ;; Check for HTTP errors
  ;;              (when (plist-get status :error)
  ;;                (error "Error al obtener palabra del dÃ­a: %s"
  ;;                       (cdr (plist-get status :error))))

  ;;              ;; Check HTTP status code
  ;;              (goto-char (point-min))
  ;;              (when (re-search-forward "^HTTP/[0-9.]+ \\([0-9]+\\)" nil t)
  ;;                (let ((status-code (string-to-number (match-string 1))))
  ;;                  (unless (= status-code 200)
  ;;                    (error "HTTP error %d al obtener palabra del dÃ­a" status-code))))

  ;;              ;; Parse JSON response
  ;;              (goto-char (point-min))
  ;;              (re-search-forward "^$")
  ;;              (let* ((json-object-type 'hash-table)
  ;;                     (json-array-type 'list)
  ;;                     (json-key-type 'string)
  ;;                     (json-data (json-read))
  ;;                     (data (gethash "data" json-data))
  ;;                     (palabra (when data (gethash "word" data))))
  ;;                (if palabra
  ;;                    (writing/rae-api-lookup palabra)
  ;;                  (message "No se pudo obtener la palabra del dÃ­a"))))
  ;;          (kill-buffer (current-buffer)))))))
#+end_src

* Buscar sinÃ³nimos
Seach for synonyms for Spanish words.

#+begin_src emacs-lisp
  (defun writing/sinonimo (palabra)
    "Busca una palabra en un diccionario de sinÃ³nimos en una ventana lateral"
    (interactive "sÂ¿QuÃ© palabra quieres buscar? ")
    (let ((url (concat "https://www.wordreference.com/sinonimos/" palabra)))
      
      ;; Create a temporary buffer for the side window
      (let ((temp-buffer (generate-new-buffer "*temp-sinonimos*")))
        
        ;; Display the temporary buffer in a side window
        (let ((side-window (display-buffer-in-side-window 
                            temp-buffer 
                            '((side . right) 
                              (window-width . 80)
                              (window-parameters . ((no-delete-other-windows . t)))))))
          
          ;; Select the side window and load eww there
          (with-selected-window side-window
            (eww url)
            
            ;; Kill the temporary buffer since eww created its own
            (kill-buffer temp-buffer)
            
            ;; Set up the eww buffer
            (read-only-mode 1)
            (use-local-map (copy-keymap (current-local-map)))
            (local-set-key (kbd "q") 'quit-window))))))
#+end_src

* Translate from english
https://github.com/lorniu/gt.el
Translate from english to spanish

#+begin_src emacs-lisp
  (use-package gt 
    :ensure t
    :config
    (setq gt-langs '(en es))
    (setq gt-default-translator (gt-translator :engines (gt-google-engine))))
#+end_src

* TODO powerthesaurus
https://github.com/SavchenkoValeriy/emacs-powerthesaurus

#+begin_src emacs-lisp
  (use-package powerthesaurus
    :ensure t)
#+end_src

* org-remark for text annotations
Text annotations in org mode
https://github.com/nobiot/org-remark
Manual: https://nobiot.github.io/org-remark/

#+begin_src emacs-lisp
  (use-package org-remark
    :ensure t
    :after org
    :config
    (require 'org-remark-global-tracking)
    (org-remark-global-tracking-mode +1)

    ;; Create a file of notes for each file, with the buffer name appended by "-notes"
    (defun my/org-remark-file-name ()
      (concat (file-name-base (org-remark-notes-file-name-function))
              ".org"))
    (setq org-remark-notes-file-name
          #'my/org-remark-file-name)

    ;; Key-bind `org-remark-mark' to global-map so that you can call it
    ;; globally before the library is loaded.
    (define-key global-map (kbd "C-c n m") #'org-remark-mark)
    ;; The rest of keybidings are done only on loading `org-remark'
    (with-eval-after-load 'org-remark
      (define-key org-remark-mode-map (kbd "C-c n o") #'org-remark-open)
      (define-key org-remark-mode-map (kbd "C-c n n") #'org-remark-view-next)
      (define-key org-remark-mode-map (kbd "C-c n p") #'org-remark-view-prev)
      (define-key org-remark-mode-map (kbd "C-c n r") #'org-remark-remove)
      (define-key org-remark-mode-map (kbd "C-c n j") #'org-remark-change)
      )
    )
  ;; Create highlighter pens for different parts
  (with-eval-after-load 'org-remark
    ;; Since I use alternate dark and clear themes, these must be useful for both
    (org-remark-create "blue-structure"
                       '(:underline "sky blue" :background "deep sky blue")
                       '(CATEGORY "structure"))

    ;; can be properly seen in both dark and clear themes
    (org-remark-create "dark-blue-line"
                       '(:underline "deep sky blue")
                       '(CATEGORY "editing"))

    (org-remark-create "gray-plot"
                       '(:background "dim gray")
  		     '(CATEGORY "plot"))

    (org-remark-create "salmon-character"
                       '(:background "salmon")
  		     '(CATEGORY "character"))

    (org-remark-create "yellow-dialogue"
                       '(:background "yellow")
  		     '(CATEGORY "dialogue"))

    (org-remark-create "royal-blue-other"
                       '(:background "royal blue")
  		     '(CATEGORY "other"))
    )
#+end_src

* tempel - template expansion
:PROPERTIES:
:ID:       836dad1c-d03d-45d1-b9c7-0bce134fc86e
:END:
Template expansion, substituting the yasnippet package for something simpler.
https://github.com/minad/tempel

#+begin_src emacs-lisp
  (use-package tempel
    :ensure t
    :after org
    ;; Require trigger prefix before template name when completing.
    :custom
    (tempel-trigger-prefix "<")

    :init
    ;; Setup completion at point
    (defun tempel-setup-capf ()
      ;; Add the Tempel Capf to `completion-at-point-functions'.
      ;; `tempel-expand' only triggers on exact matches. Alternatively use
      ;; `tempel-complete' if you want to see all matches, but then you
      ;; should also configure `tempel-trigger-prefix', such that Tempel
      ;; does not trigger too often when you don't expect it. NOTE: We add
      ;; `tempel-expand' *before* the main programming mode Capf, such
      ;; that it will be tried first.
      (setq-local completion-at-point-functions
  		(cons #'tempel-expand
                        completion-at-point-functions)))

    (add-hook 'conf-mode-hook 'tempel-setup-capf)
    (add-hook 'prog-mode-hook 'tempel-setup-capf)
    (add-hook 'text-mode-hook 'tempel-setup-capf)
    :bind
    ;;("C-c d i" . tempel-insert)
    :config
    (setq tempel-path "~/.emacs.d/templates")
    )
#+end_src

* Create a story file on the fly
Sometimes I want to create a story prompt on the fly. These functions allow for creating the prompts and the file, so I can immediately start writing.

#+begin_src emacs-lisp
  (defvar writing-stories-directory "~/Nextcloud/escritura/historias/ejercicios"
    "Directory where org files created by `writing/create-org-file' will be stored.")

  (defun writing/create-empty-writing-file (title)
    "Create a new empty org file with name format `%Y%m%d-<title>.org', where <title> is the `title' argument with spaces replaced by underscores. The file will be stored in `writing-stories-directory'."
    (interactive "sEnter file name: ")
    (let* ((date (format-time-string "%Y%m%d"))
  	 ;; Create the filename with the timestamp and the title
           (filename (concat date "-" (replace-regexp-in-string " " "_" title) ".org"))
  	 ;; create the full path of the file
           (full-path (concat writing-stories-directory "/" filename))
  	 ;; Create a string with the title and author
  	 (initial_title (format "#+TITLE: %s\n#+AUTHOR: %s\n#+EMAIL: %s" title user-full-name user-mail-address))
  	   )
      ;; very crude way to include some title in the file created
      (append-to-file initial_title nil full-path)
      (find-file full-path)
      ))

  (defun writing/create-writing-exercise (title)
    "Create a new file with the current date and the specified TITLE.
  The file is saved in the directory specified by `writing-stories-directory'.
  The file name format is \"%Y%m%d-<text>.org\", with spaces in TEXT replaced by \"_\".
  The function runs a Python script that generates a writing prompt
  and stores the output in the file."
    (interactive "sEnter file name: ")
    (let* ((date (format-time-string "%Y%m%d"))
  	 ;; Create the filename with the timestamp and the title
           (file-name (concat date "-" (replace-regexp-in-string " " "_" title) ".org"))
  	 ;; create the full path of the file
           (file-path (concat writing-stories-directory "/" file-name))
  	 ;; Get the output from the python script
           (python-output (shell-command-to-string "python  ~/Nextcloud/escritura/software/writing_companion/writing_companion.py -s all prompt"))
  	 ;; Create the initial org front matter
  	 (initial_title (format "#+TITLE: %s\n#+AUTHOR: %s\n#+EMAIL: %s" title user-full-name user-mail-address)))
      ;; insert the data in the file
      (with-temp-file file-path
        (insert initial_title )
  	(insert "\n\n" python-output))
      ;; open the file
      (find-file file-path)
      ))
#+end_src

* Mutually exclusive writing modes
These modes should be mutually exclusive. When one is activated, all others are automatically deactivated.

The four mutually exclusive modes are:
- =my-writing-env-mode= - Distraction-free writing environment
- =my-writing-env-mode-focus= - Focused writing with narrowing to current section
- =project-writing-mode= - Project navigation with treemacs and imenu-list
- =writing/editing-mode= - Three-pane editing layout with notes

#+begin_src emacs-lisp
  (defvar my-writing-exclusive-modes
    '(my-writing-env-mode
      my-writing-env-mode-focus
      project-writing-mode
      writing/editing-mode)
    "List of writing minor modes that should be mutually exclusive.")

  (defun my-writing--deactivate-other-modes (current-mode)
    "Deactivate all writing modes except CURRENT-MODE.
  This function is called when activating any of the mutually exclusive
  writing modes to ensure only one is active at a time."
    (dolist (mode my-writing-exclusive-modes)
      (unless (eq mode current-mode)
        (when (and (boundp mode) (symbol-value mode))
          (funcall mode -1)))))
#+end_src

* writing mode function
My own writing setup function.

When I write, I find that I need to have full focus on the writing, and have a different visual aspect from my normal work. This function changes:
- the theme
- the fonts used
- activates writeroom mode, with some custom setting (width, mainly)

#+begin_src emacs-lisp
    (require 'writeroom-mode)
    (require 'fontaine)

    (defgroup my-writing-env nil
      "Customization group for writing environment."
      :group 'convenience)

    (defcustom my-writing-env-normal-theme 'ef-deuteranopia-dark
      "Theme for normal environment."
      :type 'symbol
      :group 'my-writing-env)

    (defcustom my-writing-env-work-theme 'poet
      "Theme for writing environment."
      :type 'symbol
      :group 'my-writing-env)

    (defcustom my-writing-env-normal-font 'regular
      "Fontaine preset for normal environment."
      :type 'symbol
      :group 'my-writing-env)

    (defcustom my-writing-env-work-font 'writing-big
      "Fontaine preset for writing environment."
      :type 'symbol
      :group 'my-writing-env)

    (defcustom my-writing-env-work-width 80
      "Writeroom width for writing mode."
      :type 'integer
      :group 'my-writing-env)

    (defcustom my-writing-env-normal-width 90
      "Writeroom width for normal mode."
      :type 'integer
      :group 'my-writing-env)

    (defvar-local my-writing-env--writeroom-active nil
      "Track if writeroom was activated by writing-env mode.")

    (defun my-writing-env--activate ()
      "Activate writing environment."
      (display-line-numbers-mode 1)
      (consult-theme my-writing-env-work-theme)
      (fontaine-set-preset my-writing-env-work-font)
      (setq writeroom-width my-writing-env-work-width)
      (writeroom-mode 1)
      (setq my-writing-env--writeroom-active t))

    (defun my-writing-env--deactivate ()
      "Deactivate writing environment."
      (display-line-numbers-mode -1)
      (consult-theme my-writing-env-normal-theme)
      (fontaine-set-preset my-writing-env-normal-font)
      (when my-writing-env--writeroom-active
        (writeroom-mode -1)
        (setq my-writing-env--writeroom-active nil)))

    ;;;###autoload
    (define-minor-mode my-writing-env-mode
      "Toggle a distraction-free writing environment.

    This mode changes the theme, font, and enables writeroom-mode
    with customized settings optimized for focused writing."
      :lighter " âœ"
      :global nil
      (if my-writing-env-mode
          (progn
            (my-writing--deactivate-other-modes 'my-writing-env-mode)
            (my-writing-env--activate))
        (my-writing-env--deactivate)))

    (provide 'my-writing-env-mode)

  #+END_src

* Focus writing mode function
This is the same as the =my-writing-env-mode=, but instead of opening the whole org file, it narrows to the section at point.

#+BEGIN_src emacs-lisp
  ;; ------------------------------------------------------------
  ;; Focus mode variant - narrows to current org section
  ;; ------------------------------------------------------------
  (defvar-local my-writing-env--narrowed nil
    "Track if buffer was narrowed by writing-env-mode-focus.")

  (defun my-writing-env-focus--activate ()
    "Activate writing environment and narrow to current org section."
    ;; First activate the base writing environment
    (my-writing-env--activate)
    ;; Then add narrowing if in org-mode
    (when (derived-mode-p 'org-mode)
      (org-narrow-to-subtree)
      (setq my-writing-env--narrowed t)))

  (defun my-writing-env-focus--deactivate ()
    "Deactivate writing environment and restore buffer view."
    ;; First widen if we narrowed
    (when my-writing-env--narrowed
      (widen)
      (setq my-writing-env--narrowed nil))
    ;; Then deactivate the base writing environment
    (my-writing-env--deactivate))

    ;;;###autoload
  (define-minor-mode my-writing-env-mode-focus
    "Toggle a distraction-free writing environment focused on current section.

  This mode changes the theme, font, and enables writeroom-mode
  with customized settings optimized for focused writing. Additionally,
  it narrows the buffer to the current org section at point."
    :lighter " âœðŸ”"
    :global nil
    (if my-writing-env-mode-focus
        (progn
          (my-writing--deactivate-other-modes 'my-writing-env-mode-focus)
          (my-writing-env-focus--activate))
      (my-writing-env-focus--deactivate)))

  (provide 'my-writing-env-mode-focus)
#+end_src

* TODO project writing mode
This minor mode opens two side menus to track the directory (treemacs) and the org file headings (imenu-list).

#+begin_src emacs-lisp
  (define-minor-mode project-writing-mode
    "Toggle treemacs and imenu-list together for a focused writing environment.

  When enabled, opens treemacs with the current project exclusively
  and activates imenu-list. When disabled, closes both windows.
  Focus always returns to the original buffer for seamless transitions."
    :lighter " ProjWrt"
    :global nil
    (let ((original-window (selected-window)))
      (if project-writing-mode
          ;; Enable: Open both windows, then return focus
          (progn
            (my-writing--deactivate-other-modes 'project-writing-mode)
            (treemacs-add-and-display-current-project-exclusively)
            (unless (get-buffer-window imenu-list-buffer-name)
              (imenu-list-smart-toggle))
            ;; Return focus to original window
            (when (window-live-p original-window)
              (select-window original-window)))
        ;; Disable: Close both windows, focus stays in current buffer
        (progn
          ;; Close treemacs
          (when (treemacs-get-local-window)
            (delete-window (treemacs-get-local-window)))
          ;; Close imenu-list
          (when (get-buffer-window imenu-list-buffer-name)
            (imenu-list-smart-toggle))
          ;; Ensure focus is on original window
          (when (window-live-p original-window)
            (select-window original-window))))))
#+end_src

* TODO My editing function
I want to open my own view to edit my writing.
- I want to have a left window with the index of the file, usually an org mode file, so =imenu-list= is a good candidate.
- I want the central window to have the text, so it will host the main file I want to edit, for readability.
- I want the right window to host the file with notes. In my case, I use org-remark, so I have to find the associated filename.

#+begin_src emacs-lisp
  ;; ------------------------------------------------------------
  ;; Helper utilities (lexical binding recommended)
  ;; ------------------------------------------------------------
  (defun writing/window-perc (pct)
    "Return floor of `frame-width' multiplied by PCT (float between 0 and 1)."
    (floor (* (frame-width) pct)))

  (defun writing/file-notes-filename (file)
    "Return the orgâ€‘remark notes filename for FILE.
              E.g. \"~/tmp/foo.org\" â†’ \"foo-notes.org\"."
    (let* ((base (file-name-sans-extension (file-name-nondirectory file)))
           (ext  (file-name-extension (file-name-nondirectory file))))
      (concat base "-notes." ext)))

  (defun writing/resize-margins ()
    "Center the current buffer according to `visual-fill-column-width'.
              If the desired column width exceeds the window width we do nothing
              instead of passing a negative margin to `set-window-margins'."
    (when (and (boundp 'visual-fill-column-width)
               visual-fill-column-width
               (> (window-width) visual-fill-column-width))
      (let ((margin (/ (- (window-width) visual-fill-column-width) 2)))
        (set-window-margins (selected-window) margin margin))))

  (defun writing/editing-profile ()
    "Apply the visual style you want for editing sessions.

            You can customise this function to suit your own colour/theme,
            column width, font preset, etc."
    ;; Theme â€“ change to whatever you prefer
    (when (fboundp 'consult-theme)
      (consult-theme 'leuven))

    ;; Column width for `visual-fill-column` (if you use that package)
    (when (boundp 'visual-fill-column-width)
      (setq visual-fill-column-width 90))

    ;; Font preset â€“ requires the `fontaine` package
    (when (fboundp 'fontaine-set-preset)
      (fontaine-set-preset 'editing)))

  ;; ------------------------------------------------------------
  ;; Stateâ€‘saving variables (new)
  ;; ------------------------------------------------------------
  (defvar-local writing-editing--saved-config nil
    "Window configuration saved before `writing-editing-mode' was enabled.")
  (defvar-local writing-editing--saved-theme nil
    "List of themes that were enabled before `writing-editing-mode' was turned on.")
  (defvar-local writing-editing--saved-fill-column-width nil
    "Value of `visual-fill-column-width' before the mode was enabled.")
  (defvar-local writing-editing--saved-fontaine-preset nil
    "Current Fontaine preset before the mode was enabled.")

  ;; ------------------------------------------------------------
  ;; Setup (modified to capture state)
  ;; ------------------------------------------------------------
  (defun writing-editing--setup ()
    "Create the threeâ€‘pane layout and apply the editing visual profile."
    (let* ((left-perc   0.25)
           (right-perc  0.25)
           (src-file
            (or (buffer-file-name)
                (error "Current buffer is not visiting a file; cannot enable `writing-editing-mode'")))
           (notes-file (writing/file-notes-filename src-file))
           (frame-w    (frame-width))
           (right-w    (writing/window-perc right-perc))
           (left-w     (writing/window-perc left-perc)))

      ;; ----- Save visual state -----
      (setq writing-editing--saved-config (current-window-configuration)
  	  writing-editing--saved-theme
  	  (when (boundp 'custom-enabled-themes) custom-enabled-themes)
  	  writing-editing--saved-fill-column-width visual-fill-column-width
  	  ;; NEW: store the *actual* active preset
  	  writing-editing--saved-fontaine-preset
  	  (when (boundp 'fontaine-current-preset)
              fontaine-current-preset))

      ;; ----- Layout -----
      (delete-other-windows)
      (when (require 'imenu-list nil t)
        (setq imenu-list-size left-w
              imenu-list-focus-after-activation nil)
        (imenu-list-smart-toggle))
      (switch-to-buffer (current-buffer))
      (let ((left-size (- (window-total-width) right-w)))
        (split-window-right left-size)
        (other-window 1)
        (find-file notes-file))
      (other-window -1)

      ;; ----- Apply visual profile -----
      (writing/editing-profile)

      ;; ----- Misc. -----
      (writing/resize-margins)))

  ;; ------------------------------------------------------------
  ;; Teardown (new â€“ restores visual state)
  ;; ------------------------------------------------------------
  (defun writing-editing--teardown ()
    "Restore the previous window configuration *and* visual settings."
    ;; Windows
    (when (window-configuration-p writing-editing--saved-config)
      (set-window-configuration writing-editing--saved-config))

    ;; Themes
    (when (and (boundp 'custom-enabled-themes) writing-editing--saved-theme)
      (dolist (th custom-enabled-themes)
        (unless (member th writing-editing--saved-theme)
          (disable-theme th)))
      (dolist (th writing-editing--saved-theme)
        (unless (member th custom-enabled-themes)
          (load-theme th t))))

    ;; visualâ€‘fillâ€‘columnâ€‘width
    (when (boundp 'visual-fill-column-width)
      (setq visual-fill-column-width writing-editing--saved-fill-column-width))

    ;; Fontaine preset
    (when (and (boundp 'fontaine-current-preset)
               writing-editing--saved-fontaine-preset)
      (fontaine-set-preset writing-editing--saved-fontaine-preset))

    ;; Clean up saved vars
    (setq writing-editing--saved-config nil
          writing-editing--saved-theme nil
          writing-editing--saved-fill-column-width nil
          writing-editing--saved-fontaine-preset nil))

              ;;;###autoload
  (define-minor-mode writing/editing-mode
    "Minor mode that sets up a threeâ€‘pane editing layout for the current file.

              When enabled the current frame is split into:
                â€¢ left  â€“ `imenu-list' (â‰ˆâ€¯25â€¯%)
                â€¢ centre â€“ the buffer you are currently editing
                â€¢ right â€“ a matching orgâ€‘remark notes file (â‰ˆâ€¯25â€¯%).

      Disabling the mode restores the previous window configuration *and* the
    visual settings (theme, column width, font preset)."
    :init-value nil
    :lighter " Edit"
    :global nil
    (if writing/editing-mode
        (progn
          (my-writing--deactivate-other-modes 'writing/editing-mode)
          (writing-editing--setup))
      (writing-editing--teardown)))
#+end_src

* TODO writing - scene break for multiple formats
I want to have just one line, macro or function to signal the change of scenes, independent from the export backend.

#+begin_src emacs-lisp
    (defun org-export-replace-scene-breaks (text backend _info)
    "Replace SCENE-BREAK markers with backend-appropriate scene separators."
    (let ((replacement
           (pcase backend
             ;; Markdown, ASCII, man: visible marker for reliability
             ((or 'ascii 'md 'man)
              "\n***\n\n")
             ;; HTML: visual spacing
             ('html "<br><br><br>\n")
             ;; LaTeX/PDF: vertical space
             ('latex "\\vspace{\\baselineskip}\\vspace{\\baselineskip}\\vspace{\\baselineskip}\n")
             ;; Everything else: 3 blank lines
             (_ "\n\n\n"))))
      (replace-regexp-in-string "SCENE-BREAK" replacement text t t)))

  (add-to-list 'org-export-filter-final-output-functions #'org-export-replace-scene-breaks)
#+end_src

This should be used
At the top of your `.org` document, add:

#+MACRO: scene-break SCENE-BREAK

You insert {{{scene-break}}} wherever you want a scene break.
{{{scene-break}}}

The macro expands to the literal text SCENE-BREAK.

After Org finishes generating the export, the filter org-export-replace-scene-breaks replaces all SCENE-BREAK markers with the correct text (three newlines, <br>, etc.).

* TODO emacs-writing-template for novel writing
My personal package for creating novel files templates for rapid deployment.

#+begin_src emacs-lisp
  (use-package emacs-writing-template
    :ensure t
    :vc (:url "https://codeberg.org/jcastp/emacs-writing-template"
  	    :branch "main"
  	    :rev :newest))
#+end_src

* org-ql searches for writing
These are custom made org-ql searches for our writing environment and workflow.

#+begin_src emacs-lisp
  (defun writing/org-find-pov (char)
    "Show sparse tree of scenes with POV character."
    (interactive "sCharacter (POV): ")
    (org-ql-search (current-buffer)
      `(and (heading)
            (let ((pov (org-entry-get (point) "POV")))
              (and pov (string-match-p ,char pov))))))

  ;; custom finder function for multivalued properties, with values separated by commas.
  (defun writing/org-find-character (char)
    "Show sparse tree of scenes with CHARACTER."
    (interactive "sCharacter name: ")
    (org-ql-search (current-buffer)
      `(and (heading)
            (let* ((chars-prop (org-entry-get (point) "Characters"))
                   (chars-list (when chars-prop
                                 (mapcar #'string-trim 
                                         (split-string chars-prop ",")))))
              (member ,char chars-list)))))

  (defun writing/org-find-plot (term)
    "Show sparse tree of scenes matching TERM in plot."
    (interactive "sPlot term: ")
    (org-ql-search (current-buffer)
      `(and (heading)
            (let ((plot (org-entry-get (point) "plot")))
              (and plot (string-match-p ,term plot))))))

  (defun writing/org-find-location (loc)
    "Show sparse tree of scenes with LOCATION."
    (interactive "sLocation: ")
    (org-ql-search (current-buffer)
      `(and (heading)
            (let ((location (org-entry-get (point) "location")))
              (and location (string-match-p ,loc location))))))

  (defun writing/search-todos-recursive ()
    "Search for TODO items (not DONE) in current directory tree using org-ql.
  Finds all .org files recursively from the current buffer's directory
  and displays all TODO keywords with an active (non-DONE) status.
  Results are grouped by file for easy navigation."
    (interactive)
    (let* ((current-dir (file-name-directory (or (buffer-file-name) default-directory)))
           (org-files (directory-files-recursively current-dir "\\.org$")))
      (if org-files
          (org-ql-search org-files
            '(and (todo) (not (done)))
            :title "TODO items in writing project"
            :super-groups '((:auto-map (lambda (item)
                                         (concat "File: "
                                                 (file-name-nondirectory (buffer-file-name)))))))
        (message "No .org files found in %s and subdirectories" current-dir))))
#+end_src

* TODO capture to writing notes
This function determines the appropriate notes file for org-capture in the writing environment.

The capture target is determined by checking files in this order:
1. =notes/notes.org= (relative to current directory, usually relative to novel.org)
2. =notas/notas.org= (spanish version, relative to current directory, usually relative to novela.org)
3. =novel-notes.org= (in current directory)
4. =notes.org= (in current directory)
5. Current buffer if none of the above exist

#+begin_src emacs-lisp
  (defun writing/capture-target-file ()
    "Determine the appropriate notes file for org-capture in writing environment.
  Uses `project-current' to find the project base directory as reference point.
  Returns the file path based on the following priority:
  1. notes/notes.org (relative to project root)
    1.1 notas/notas.org - spanish (relative to project root)
  2. novel-notes.org (in project root)
  3. notes.org (in project root)
  4. current buffer if none of the above exist"
    (let* ((project-dir (if-let ((project (project-current)))
                            (project-root project)
                          (file-name-directory (or (buffer-file-name) default-directory))))
           (notes-subdir-en (expand-file-name "notes/notes.org" project-dir))
           (notes-subdir-es (expand-file-name "notas/notas.org" project-dir))
           (novel-notes (expand-file-name "novel-notes.org" project-dir))
           (notes (expand-file-name "notes.org" project-dir)))
      (cond
       ((file-exists-p notes-subdir-en) notes-subdir-en)
       ((file-exists-p notes-subdir-es) notes-subdir-es)
       ((file-exists-p novel-notes) novel-notes)
       ((file-exists-p notes) notes)
       (t (or (buffer-file-name) (expand-file-name "notes.org" project-dir))))))

  (defvar writing/capture-templates
    '(("w" "Writing Note" entry
       (file+headline writing/capture-target-file "Notes")
       "** TODO %?\n  %U\n  %i"
       :empty-lines 1))
    "Capture templates specific to the writing environment.")

  (defun writing/capture-to-file ()
    "Capture notes to writing project or file."
    (interactive)
    ;; Choose the destination that actually exists.
    (let ((target (writing/capture-target-file)))
      ;; Build a temporary capture template that points at TARGET.
      (let ((org-capture-templates
    	   writing/capture-templates))
        ;; Run the capture UI.
        (org-capture))))

  ;; adding a keybinding, but also reachable through an hydra function below
  (global-set-key (kbd "C-c W") 'writing/capture-to-file)  
#+end_src

* hydra for functions
I want to create a hydra function for the most useful functions when writing.

#+begin_src emacs-lisp
   (defhydra hydra-writing (:color blue :hint nil)
     "
   ^Modes^                   ^Writing Tools^       ^Count words^         ^Searches^
   ^^^^^^^^------------------------------------------------------------------------
   _p_: Project mode         _r_: RAE dictionary   _n_: Count words      _u_: Find POV        
   _w_: Writing mode         _s_: Synonyms         _m_: EWS Word count   _i_: Find character  
   _f_: Focus writing mode   _l_: Translate        _t_: Track table      _o_: Find plot       
   _e_: Editing mode         _d_: Thesaurus                            _y_: Find location
                           _c_: writing note                         _a_: Find TODOs
   _q_: Quit
   "
     ;; Modes
     ("p" project-writing-mode "project mode")    
     ("w" my-writing-env-mode "writing mode")
     ("f" my-writing-env-mode-focus "focus mode")    
     ("e" writing/editing-mode "editing mode")
         
     ;; Writing tools
     ("r" writing/rae-api-lookup "RAE dictionary")
     ("s" writing/sinonimo "synonyms")
     ("l" writing/translate "translate")
     ("d" powerthesaurus-lookup-dwim "thesaurus")
     ("c" writing/capture-to-file "capture writing note")    

     ;; Count words
     ("n" org-context-count-words "count words")
     ("m" writing/ews-org-count-words "add word properties")
     ("t" org-tracktable-write "track table")
     
     ;; Novel searches
     ("u" writing/org-find-pov "find POV")
     ("i" writing/org-find-character "find character")
     ("o" writing/org-find-plot "find plot")
     ("y" writing/org-find-location "find location")
     ("a" writing/search-todos-recursive "find TODOs")


     ;; Exit
     ("q" nil "quit"))

   ;; global key for this macro
   (keymap-global-set "<f8> <f8>" #'hydra-writing/body)
#+End_src

* Writing prefix keymap
#+begin_src emacs-lisp
  ;; all my writing functions in a convenient keybinding map
  (defvar-keymap my/key-prefix-writing-map
    :doc "Functions related to writing"
    ;; writing mode
    "a" #'my-writing-env-mode
    "f" #'my-writing-env-mode-focus
    "e" #'writing/editing-mode
    "w" #'writing/ews-org-count-words
    "c" #'org-context-count-words
    ;; writing exercises
    "r" #'writing/create-writing-exercise
    "q" #'writing/create-empty-writing-file
    "s" #'writing/sinonimo
    ;; hydra keybinding
    "k" #'hydra-writing/body
    )
#+end_src
